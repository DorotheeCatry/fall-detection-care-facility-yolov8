{# detection/templates/detection/test_detection.html #}
{% extends "base.html" %}

{% block title %}Test Fall Detection{% endblock %}

{% block content %}
<div class="max-w-2xl mx-auto py-6">
    {# ──────────────────────────────────────────────────────────── #}
    {# BACK TO ALERTS LINK + PAGE HEADING                         #}
    <div class="mb-6 flex flex-col sm:flex-row justify-between items-start sm:items-center">
        <h1 class="text-2xl font-bold text-rose-900 mb-4 sm:mb-0">
            Live Fall Detection & File Upload
        </h1>
        <a href="{% url 'detection:alerts' %}" class="btn-secondary flex items-center text-sm">
            <span class="mr-1">←</span>
            Back to Alerts
        </a>
    </div>

    {# ──────────────────────────────────────────────────────────── #}
    {# SHOW ANY DJANGO MESSAGES                                    #}
    {% if messages %}
        <div class="mb-6">
            {% for message in messages %}
                <div class="p-4 
                    {% if message.tags == 'success' %}
                        bg-emerald-50 text-emerald-800 border-2 border-emerald-200
                    {% elif message.tags == 'error' %}
                        bg-rose-50 text-rose-800 border-2 border-rose-200
                    {% else %}
                        bg-sky-50 text-sky-800 border-2 border-sky-200
                    {% endif %}
                    rounded-md mb-2">
                    {{ message }}
                </div>
            {% endfor %}
        </div>
    {% endif %}

    {# ──────────────────────────────────────────────────────────── #}
    {# HIDDEN CSRF TOKEN FOR JAVASCRIPT BELOW                      #}
    <input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">
    {# ──────────────────────────────────────────────────────────── #}


    {# ──────────────────────────────────────────────────────────── #}
    {# LIVE VIDEO DETECTION CARD                                   #}
    <div class="card mb-8 border-2 border-rose-100">
        <h2 class="text-lg font-medium text-rose-900 mb-4">Live Video Detection</h2>

        {# Conteneur fixe (640×360) pour le video + canvas + status #}
        <div style="border:2px solid #f87171; width:640px; height:500px; position:relative; margin-bottom:1rem;">
            <video id="videoElement"
                   width="640"
                   height="480"
                   autoplay
                   playsinline
                   style="background:#000; display:block;">
            </video>
           <button id="togglePose" class="mb-2 px-3 py-1 bg-rose-200 text-rose-800 rounded font-medium">
              Toggle Pose Display
           </button>
            <canvas id="outputCanvas"
                    width="640"
                    height="360"
                    style="position:absolute; top:0; left:0;">
            </canvas>
            <div id="status"
                 style="position:absolute; top:8px; right:8px; display:none;"
                 class="px-3 py-1 rounded-full text-sm font-medium bg-rose-500 text-white">
            </div>
        </div>

        {# Le bouton pour activer / désactiver la caméra #}
        <div class="flex justify-between items-center">
            <button id="startCamera" class="btn-primary">Start Camera</button>
            <div id="detectionStatus" class="text-rose-600 font-medium"></div>
        </div>
    </div>
    {# ──────────────────────────────────────────────────────────── #}


    {# ──────────────────────────────────────────────────────────── #}
{# ──────────────────────────────────────────────────────────── #}
{# UPLOAD PREVIEW CARD – s’affiche si processed_image existe #}
{% if processed_image %}
  <div id="previewCard" class="card mb-8 border-2 border-rose-100">
    <h2 class="text-lg font-medium text-rose-900 mb-4">Preview &amp; Détection</h2>
    <div class="flex justify-center mb-4">
      <img src="data:image/jpeg;base64,{{ processed_image }}"
           alt="Processed preview"
           class="max-w-full h-auto rounded-md shadow-sm"/>
    </div>
    <p class="text-xl font-semibold text-rose-800 mb-4">
      {% if fall_detected %}
        Chute détectée ! Confiance : {{ confidence|floatformat:1 }} %
      {% else %}
        Aucune chute détectée.
      {% endif %}
    </p>
    <button type="button" id="resetForm" class="btn-secondary">Réinitialiser</button>
  </div>
{% endif %}

{# ──────────────────────────────────────────────────────────── #}
{# UPLOAD FORM CARD – caché quand preview actif #}
<div id="uploadCard" class="card mb-6 border-2 border-rose-100"
     {% if processed_image %}style="display:none"{% endif %}>
  <h2 class="text-lg font-medium text-rose-900 mb-4">Upload Test Media</h2>
  <form method="post" enctype="multipart/form-data"
        action="{% url 'detection:test_detection' %}"
        class="space-y-6">
    {% csrf_token %}
    <div class="border-2 border-rose-100 rounded-lg p-6">
      <label for="id_upload_file" class="form-label text-rose-900">Select Video or Image</label>
      <div class="mt-2 flex justify-center rounded-lg border-2 border-dashed border-rose-200 px-6 py-10">
        <div class="text-center">
          <div class="text-rose-300 mb-4">📷</div>
          <div class="flex text-sm leading-6 text-gray-600">
            <label for="id_upload_file"
                   class="relative cursor-pointer rounded-md bg-white font-semibold text-rose-600 
                   focus-within:outline-none focus-within:ring-2 focus-within:ring-rose-600
                   focus-within:ring-offset-2 hover:text-rose-500">
              <span>Upload a file</span>
              <input id="id_upload_file"
                     name="upload_file"
                     type="file"
                     class="sr-only"
                     accept="image/*,video/*"
                     required>
            </label>
            <p class="pl-1">ou glisser‐déposer</p>
          </div>
          <p class="text-xs leading-5 text-gray-600">MP4, MOV, JPG, PNG jusqu’à 10 Mo</p>
          <div id="file-name" class="mt-2 text-sm text-gray-500"></div>
        </div>
      </div>
    </div>
    <div>
      <label for="id_description" class="form-label text-rose-900">Description (Optionnel)</label>
      <textarea id="id_description"
                name="description"
                rows="3"
                class="form-input border-2 border-rose-100 focus:border-rose-300 focus:ring focus:ring-rose-200"
                placeholder="Ajoutez des détails…"></textarea>
    </div>
    <div class="flex items-center justify-between">
      <button type="submit" class="btn-primary">Run Detection</button>
      <a href="{% url 'detection:alerts' %}" class="text-sm text-gray-600 hover:text-gray-900">Cancel</a>
    </div>
  </form>
</div>

    {# ──────────────────────────────────────────────────────────── #}


    {# ──────────────────────────────────────────────────────────── #}
    {# TESTING INFORMATION BOX                                     #}
    <div class="bg-amber-50 border-2 border-amber-200 rounded-lg p-4">
        <div class="flex">
            <div class="flex-shrink-0 text-amber-400">⚠️</div>
            <div class="ml-3">
                <h3 class="text-sm font-medium text-amber-800">Testing Information</h3>
                <div class="mt-2 text-sm text-amber-700">
                    <p>
                        Ceci est un environnement de test. Toutes les alertes créées ici
                        seront marquées comme « test » et peuvent être reconnues sans affecter
                        les statistiques réelles.
                    </p>
                </div>
            </div>
        </div>
    </div>
    {# ──────────────────────────────────────────────────────────── #}
</div>

{# ────────────────────────────────────────────────────────────────────────── #}
{# NOTE : On importe Mediapipe Tasks‐Vision depuis un CDN, pas un import “bare”  #}
{# ────────────────────────────────────────────────────────────────────────── #}
<script type="module">
  console.log("🔴 test_detection.js has démarré (module).");

  // Import Mediapipe Tasks-Vision depuis le CDN
  import {
    FilesetResolver,
    PoseLandmarker
  } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";
  let showPose = true;

  document.getElementById('togglePose').addEventListener('click', () => {
      showPose = !showPose;
  });
  // Récupération des éléments du DOM
  let videoElement    = document.getElementById("videoElement");
  let canvas          = document.getElementById("outputCanvas");
  let ctx             = canvas.getContext("2d");
  let startButton     = document.getElementById("startCamera");
  let statusDiv       = document.getElementById("status");
  let detectionStatus = document.getElementById("detectionStatus");

  let stream          = null;
  let poseLandmarker  = null;
  let isProcessing    = false;

  // Canvas caché pour capturer l’image complète à envoyer à YOLO
  let hiddenCanvas  = document.createElement("canvas");
  let hiddenCtx     = hiddenCanvas.getContext("2d");

  // Intervalle minimum (en ms) entre deux envois au serveur YOLO
  const YOLO_INTERVAL = 2000;
  let lastYoloTime    = 0;

  // 1) Initialisation de PoseLandmarker (Mediapipe Tasks-Vision)
  async function createPoseLandmarker() {
    const vision = await FilesetResolver.forVisionTasks(
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
    );

    poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
      baseOptions: {
        modelAssetPath:
          "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
        delegate: "GPU"
      },
      runningMode: "VIDEO"
    });

    console.log("✅ PoseLandmarker ready.");
    detectionStatus.textContent = "PoseLandmarker chargé ; démarrage de la caméra…";
    startCamera();
  }
  function updateStatus(statusText) {
      if (statusText && statusText.trim() !== "") {
          statusDiv.textContent = statusText;
          statusDiv.style.display = "block";  // Affiche la div
      } else {
          statusDiv.style.display = "none";   // Cache la div si vide ou null
      }
  }
  // 2) Démarrer la caméra (getUserMedia + play)
  async function startCamera() {
    try {
      console.log("➔ getUserMedia() en cours…");
      stream = await navigator.mediaDevices.getUserMedia({ video: true });
      console.log("➔ getUserMedia() OK");

      videoElement.srcObject = stream;
      await videoElement.play();
      console.log("➔ videoElement.play() OK");

      // Ajuster la taille du canvas visible
      canvas.width  = videoElement.clientWidth  || 640;
      canvas.height = videoElement.clientHeight || 360;

      // Ajuster la taille du canvas caché en résolution native
      hiddenCanvas.width  = videoElement.videoWidth  || 640;
      hiddenCanvas.height = videoElement.videoHeight || 360;

      startButton.textContent = "Stop Camera";
      statusDiv.style.display = "none";

      detectPoses();
    } catch (err) {
      console.error("❌ startCamera() getUserMedia erreur :", err);
      detectionStatus.textContent = "Erreur caméra : " + err.message;
    }
  }

  // 3) Arrêter la caméra
  function stopCamera() {
    if (stream) {
      stream.getTracks().forEach((track) => track.stop());
      videoElement.srcObject = null;
      startButton.textContent = "Start Camera";
      statusDiv.style.display = "none";
      isProcessing = false;
    }
  }

  // 4) Boucle principale : détecter la pose et envoyer toutes les YOLO_INTERVAL ms
  async function detectPoses() {
    if (!stream || isProcessing) return;
    isProcessing = true;

    while (videoElement.srcObject) {
      // 4a) PoseLandmarker sur chaque frame
      const result = await poseLandmarker.detectForVideo(
        videoElement,
        performance.now()
      );

      if (
        result.landmarks &&
        Array.isArray(result.landmarks) &&
        result.landmarks.length > 0
      ) {
        const singleLandmarks = result.landmarks[0];
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawLandmarks(singleLandmarks);
      }

      // 4b) Toutes les YOLO_INTERVAL ms, on envoie une image au serveur YOLO
      const now = performance.now();
      if (now - lastYoloTime > YOLO_INTERVAL) {
        lastYoloTime = now;
        sendFrameToYolo();
      }

      await new Promise((r) => requestAnimationFrame(r));
    }

    isProcessing = false;
  }

  // 5) Capturer la frame dans le canvas caché et envoyer au backend
  function sendFrameToYolo() {
    try {
      // 5a) On dessine la vidéo dans le canvas caché
      hiddenCtx.drawImage(
        videoElement,
        0,
        0,
        hiddenCanvas.width,
        hiddenCanvas.height
      );

      // 5b) On récupère la chaîne base64 (JPEG)
      const dataUrl = hiddenCanvas.toDataURL("image/jpeg", 0.8);
      // Extraire uniquement la partie après la virgule
      const base64String = dataUrl.split(",", 2)[1];

      // 5c) Appel POST vers /detection/run-yolo/
      fetch("{% url 'detection:run_yolo' %}", {
        method: "POST",
        credentials: "same-origin",    // ← essentiel pour envoyer le cookie de session
        headers: {
          "Content-Type": "application/json",
          "X-CSRFToken": document.querySelector("[name=csrfmiddlewaretoken]").value
        },
        body: JSON.stringify({ image: base64String })
      })
        .then((res) => {
          if (!res.ok) {
            console.error("KO /run-yolo/ status :", res.status);
            return res.json().then((err) => console.error(err));
          }
          return res.json();
        })
        .then((data) => {
          if (data && data.fall) {
            // Si YOLO a détecté une chute :
            statusDiv.style.display = "block";

            const confidenceValue = data.confidence ? (data.confidence * 100).toFixed(1) : "N/A";
            detectionStatus.textContent = `Fall detected! Confidence: ${confidenceValue}%`;
            updateStatus(detectionStatus.textContent);
            console.log("✅ Chute détectée avec confiance :", confidenceValue);
            // 5d) Créer l’alerte en base via create-alert
            fetch("{% url 'detection:create_alert' %}", {
              method: "POST",
              credentials: "same-origin",  // ← ici aussi pour la session
              headers: {
                "Content-Type": "application/json",
                "X-CSRFToken": document.querySelector("[name=csrfmiddlewaretoken]").value
              },
              body: JSON.stringify({
                type: "live_camera",
                description: "Fall detected via YOLOv8",
                yolo_confidence: data.confidence,
                yolo_class:       "Fall-Detected",
                yolo_image:       base64String,
              })
            }).then((r) => {
              if (r.ok) { 
                detectionStatus.textContent = "Fall alert created !";
                setTimeout(() => {
                  detectionStatus.textContent = "";
                  statusDiv.style.display = "none";
                }, 3000);
              }
            });
          }
        })
        .catch((err) => {
          console.error("❌ Erreur appel /run-yolo/ :", err);
        });
    } catch (err) {
      console.error("❌ sendFrameToYolo erreur :", err);
    }
  }

  // 6) Fonction pour dessiner les landmarks Mediapipe
  function drawLandmarks(landmarks) {
    if (!showPose) return;
    ctx.strokeStyle = "#10B981";
    ctx.lineWidth = 2;
    const connections = [
      [11, 12], [11, 13], [13, 15],
      [12, 14], [14, 16], [11, 23],
      [12, 24], [23, 24], [23, 25],
      [25, 27], [24, 26], [26, 28]
    ];
    for (const [s, e] of connections) {
      ctx.beginPath();
      ctx.moveTo(
        landmarks[s].x * canvas.width,
        landmarks[s].y * canvas.height
      );
      ctx.lineTo(
        landmarks[e].x * canvas.width,
        landmarks[e].y * canvas.height
      );
      ctx.stroke();
    }
    ctx.fillStyle = "#059669";
    for (const lm of landmarks) {
      ctx.beginPath();
      ctx.arc(
        lm.x * canvas.width,
        lm.y * canvas.height,
        4,
        0,
        2 * Math.PI
      );
      ctx.fill();
    }
  }

  // 7) Événement clic sur le bouton pour activer/désactiver la caméra
  startButton.addEventListener("click", () => {
    if (stream) stopCamera();
    else startCamera();
  });

  // 8) Au chargement de la page, on initialise Mediapipe + on lance la caméra
  window.addEventListener("DOMContentLoaded", () => {
    createPoseLandmarker().catch((err) => {
      console.error("❌ Impossible d'initialiser PoseLandmarker :", err);
      detectionStatus.textContent = "Erreur chargement PoseLandmarker : " + err.message;
    });
  });
</script>

{# ──────────────────────────────────────────────────────────── #}
{# SCRIPT POUR GÉRER L’AFFICHAGE DU NOM DE FICHIER SÉLECTIONNÉ   #}
<script>
  // show selected filename
  const input     = document.getElementById('id_upload_file');
  const fileNameD = document.getElementById('file-name');
  if (input) {
    input.addEventListener('change', () => {
      const f = input.files[0];
      fileNameD.textContent = f ? f.name : '';
    });
  }
  // reset to upload form
  const resetBtn = document.getElementById('resetForm');
  if (resetBtn) {
    resetBtn.addEventListener('click', () => {
      document.getElementById('previewCard').style.display = 'none';
      const u = document.getElementById('uploadCard');
      u.style.display = 'block';
      input.value = '';
      fileNameD.textContent = '';
    });
  }
</script>

{% endblock %}

